local ecnet = require("ecnet");
os.loadAPI("hash");

local ADDRESS_CHANNEL = 25783;
local RESPONSE_CHANNEL = 25787;
local modem = peripheral.find("modem");
s_modem = ecnet.wrap(modem);

address = "none"

local connected = false

local UPDATE_CHANNEL = 3618;
local UPDATE_PASSHASH = "79b577d198b08557e89025d6e8ab48e5fb579f541debfe0acfcc34646c97acfc";

-- value of dat.type
local NETWORK_BKRESPONSE = "NETWORK_BKRESPONSE"; -- response to client
local NETWORK_ADDUSERDAT = "NETWORK_ADDUSERDAT"; -- add a new user to the database
local NETWORK_ISAUTHUSER = "NETWORK_ISAUTHUSER"; -- check if the users credentials are correct, sends back a boolean
local NETWORK_GETBALANCE = "NETWORK_GETBALANCE"; -- gets users balance, requires auth
local NETWORK_MODBALANCE = "NETWORK_MODBALANCE"; -- adds/subtracts from users balance, requires auth
local NETWORK_ADDADDRESS = "NETWORK_ADDADDRESS"; -- add an address that is authorized to do ATM stuff, requires a special password
local NETWORK_ISAUTHADDR = "NETWORK_ISAUTHADDR"; -- ask if address is authed
local NETWORK_CHARGENEAL = "NETWORK_CHARGENEAL"; -- charge user for somthing (can only be used to remove money so requires less authorization) in future may swap this out for a wire transfer
local NETWORK_CHARGERAIL = "NETWORK_CHARGERAIL"; -- charge user for railway fair

function checkConnection()
	s_modem.connect(address, 4);
end

-- blocking, use this from a parallel
function checkForUpdates()
	while true do
		local sender, msg = s_modem.receive(address);

		if type(msg) == "string" then
			if hash.hash(msg) == UPDATE_PASSHASH then
				shell.run("/install");
			end
		end
	end
end

-- generates a random password
function genPassword()

	all = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{}:',.<>/?=+-_!@#$%^&*()\\|[];"

	pass = ""

	for i = 1, 25 do
		r = math.random(#all);
		pass = pass.. string.sub(all, r, r);
	end

	return pass;

end

function connect()
	print("connecting to server");
	-- attemt to connect loop
	while not connected do
		print("getting server address");
		-- ask the broadcast channel what the bank server address is
		modem.transmit(ADDRESS_CHANNEL, RESPONSE_CHANNEL, "DNS_REQ BANK");
		modem.open(RESPONSE_CHANNEL);
		parallel.waitForAny(function()
			_, __, ___, ____, address, ______ = os.pullEvent("modem_message");
		end, 
		function()
			sleep(3);
		end)
		
		modem.close(RESPONSE_CHANNEL);
		print("address recieved: " .. address);

		connected = s_modem.connect(address, 3);
	end
	print("connected to server");
	-- we should be connected to the server now

	-- start update checker

end

function addAuthAddress(password)
	checkConnection()
	local dat = {};
	dat.type = NETWORK_ADDADDRESS;
	dat.pass = password;
	s_modem.send(address, dat);

	local sender, msg = s_modem.receive(address, 5);
	if msg == nil then
		print("timed out");
	else
		if type(msg == "boolean") then
			if msg then
				print("success!");
			else
				print("failed to authenticate!");
			end
		else
			print("result: " .. msg);
		end
	end
end

-- returns a boolean
function addNewUser(name, password)
	checkConnection()
	local dat = {};
	dat.type = NETWORK_ADDUSERDAT;
	dat.name = name;
	dat.pass = password;
	s_modem.send(address, dat);

	local sender, msg = s_modem.receive(address, 15);
	if msg == nil then
		print("timed out");
	else
		if type(msg == "boolean") then
			return msg;
		end
	end
	return false;
end

-- returns a boolean
function checkUserCredentials(name, password) 
	checkConnection()
	local dat = {};
	dat.type = NETWORK_ISAUTHUSER;
	dat.name = name;
	dat.pass = password;
	s_modem.send(address, dat);

	local sender, msg = s_modem.receive(address, 15);
	if msg == nil then
		print("timed out");
	else
		if type(msg == "boolean") then
			return msg;
		end
	end
	return false;

end

-- returns a table containing .auth and .bal
function getUserBalance(name, password)
	checkConnection()
	local dat = {};
	dat.type = NETWORK_GETBALANCE;
	dat.name = name;
	dat.pass = password;
	s_modem.send(address, dat);

	local sender, msg = s_modem.receive(address, 15);
	if msg == nil then
		print("timed out");
	end
	return msg;
end

-- returns a boolean
function addBalance(name, password, ammount) 
	checkConnection()
	local dat = {};
	dat.type = NETWORK_MODBALANCE;
	dat.name = name;
	dat.pass = password;
	dat.val = ammount;
	s_modem.send(address, dat);

	local sender, msg = s_modem.receive(address, 15);
	if msg == nil then
		print("timed out");
	else
		if type(msg == "boolean") then
			return msg;
		end
	end
	return false;

end

-- returns a boolean
function subBalance(name, password, ammount)
	checkConnection()
	return addBalance(name, password, -ammount);
end

-- returns a boolean
function isAuthAddr()
	checkConnection()
	local dat = {};
	dat.type = NETWORK_ISAUTHADDR;
	s_modem.send(address, dat);

	local sender, msg = s_modem.receive(address, 15);
	if msg == nil then
		print("timed out");
	else
		if type(msg == "boolean") then
			return msg;
		end
	end
	return false;
end

-- returns a boolean
function chargeRailFair(name, password) 
	checkConnection()
	local dat = {};
	dat.type = NETWORK_CHARGERAIL;
	dat.name = name;
	dat.pass = password;
	s_modem.send(address, dat);

	local sender, msg = s_modem.receive(address, 15);
	if msg == nil then
		print("timed out");
	else
		if type(msg == "boolean") then
			return msg;
		end
	end
	return false;

end

